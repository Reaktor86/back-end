isset - проверить существование переменной
$_POST["name"] - взять то, что было отправлено в форме по методу post
$array[] = записать новое значение в массив
. конкатинация
(int)$name - преобразовать в число
elseif пишется слитно
$newOleg = "Oleg $number"; // в двойные кавычки можно вставлять переменные, в одинарные нельзя
die() либо exit(); // прерывает выполнение скрипта (все, что дальше - не выполнится)

echo - принимает переданное значение и в виде строки пересылает браузеру
print_r - вывести в браузер структуру и содержание массива
var_dump - узнать тип переменной
<pre> и </pre> делают массив читаемее

ФУНКЦИИ

$foo = function () use ($global) {
};
$foo(); // правильное использование глобальной переменной в анонимной функции

&$name // аргумент становится ссылкой, как ссылка на сайте

var_dump(date("Y-M-d H:m:s")); // вывести дату по маске
sort (много вариаций) - сортировка массива
count($array) - длина массива
require('/') include_once() включить код из другого файла
rand() // генерация случайных целых чисел
strstr — Находит первое вхождение подстроки
strlen - длина строки (побайтовый!)
mb_strlen - длина строки
strpos(где ищем, 'что ищем') - возвращает первое вхождение (0,1,2 и т.п)
stripos - тоже самое, только без учета регистра
strrpos - последнее вхождение
strripos - последнее вхождение, без учета регистра
substr('что обрезаем', откуда обрезаем, длина обрезания) - побайтовый!
mb_substr - не побайтовый
str_replace('что заменяем', 'чем заменяем', где заменяем)
explode('разделитель', что разделяем) // разбить строку на массив
implode // слить массив в строку
array_key_exists // существует ли ключ в массиве
in_array // существует ли значение в массиве
is_array // является ли переменная массивом
empty — Проверяет, пуста ли переменная
round - округлить до опр. кол-ва знаков
time - кол-во секунд с 1 января 1970 г
unset($array['name']) разрегестрировать ячейку

РАБОТА С ФАЙЛАМИ

fopen("файл для открытия text.txt", "режим")
Режимы:
r // для чтения
r+ // для чтения и записи
w // создать новый файл. если файл существует, то очистить его
w+ // тоже самое, только чтение+запись
а // записать в конец
а+ // записать в конец чтение/запись
fwrite("в какой файл записать", "что записать")
fpassthru("файл") - показать содержимое файла как echo
file("файл, который надо построчно запихнуть в массив")
flock("файл", константа) блокировать файл на чтение/запись, разблокировать
file_get_contents("файл") возвращает содержимое файла
file_put_contents("файл", "что положить", FILE_APPEND) положить контент в конец файла
(по умолчанию перезаписывает весь файл)
scandir -  Получить список файлов и каталогов, расположенных по указанному пути
scandir('$_SERVER['DOCUMENT_ROOT']' . '/dir')
is_dir() // является ли элемент директорией
filectime() // дата создания файла
filetype() // какой тип файла
filesize() // размер файла в байтах
stat() // возвращает статистику по файлу

КУКИ

setcookie('name', 'value', 0, '/') создать куки
0 - время действия (0 - сессионная, time() + 100 - 100 секунд)
/ - область видимости, в данном случае на всех страницах сайта

setcookie('name', '', time() - 10, '/') удалить куки с этим именем

$_SESSION работает также, как обычный массив
В $_SESSION можно хранить массивы (в куки нельзя)
Перед тем, как юзать, надо начать сессию командой session_start();

ЗАПРОСЫ

$json = file_get_contents('php://input'); // взять содержимое файла
$request = json_decode($json);  // и конвертировать из json в привычный формат
$userData = json_encode($array);
file_put_contents("save.txt", $userData, FILE_APPEND); // записат в файл

Request - это запрос к серверу от клиента
GET - метод пересылки данных от клиента к серверу с помощью URL со знаком ?
$name = $_GET['name'] - перехватить из URL get-запрос с ключом name и записать его в $name

$mysql->close(); - закрыть соединение mysql (используется, если использовал атрибут action)
затем сделать переадресацию на страницу:
header('Location: /');

Результат запроса приходит как объект.
Чтобы конвертировать в массив: $result->fetch_assoc();


ОЧИСТКА полей, которые ввел пользователь (логин, пароль)

filter_var — Фильтрует переменную с помощью определённого фильтра
filter_var('bob@example.com', FILTER_VALIDATE_EMAIL)
filter_var('http://example.com', FILTER_VALIDATE_URL, FILTER_FLAG_PATH_REQUIRED)
filter_var('строка', FILTER_SANITIZE_STRING) Удаляет теги, при необходимости удаляет или кодирует специальные символы.

trim() Удаляет пробелы из начала и конца строки
trim(где удаляем, что удаляем) - можно удалить определенные символы с начала и конца
strip_tags -- Удаляет HTML и PHP тэги из строки

Обработка полей формы:

+ удалить пробелы в начале и в конце
+ очистить от недопустимых символов
+ длина
+ хэширование пароля (md5)

ООП

$obj instanceof Card - является ли $obj экземпляром класса Card
public - свойство может быть использовано везде
private - свойство может быть использовано только внутри методов этого же класса
protected - тот же private, только учитывает extends (можно испоььзовать в дочерних классах)


ЗАКОДИРОВАТЬ ПАРОЛЬ

$sold = 'web2020';
$hashString = $userPassword . $sold;
return md5($hashString);

ФОРМЫ

action="handler1.php" - скрипт, который будет выполняться при нажатии на submit
method="GET" - метод запроса

EXCEPTION

throw new \Exception("Неверные данные");

try {
вызов метода
}
catch (Exception $e) {
var_dump($e->getMessage());
}



РАЗНОЕ

PHP_EOL // символ конца строки
